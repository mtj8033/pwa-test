{"version":3,"sources":["setupServiceWorker.js","node_modules/idb/build/esm/chunk.js","node_modules/idb/build/esm/index.js","node_modules/idb/build/esm/async-iterators.js","node_modules/idb/with-async-ittr.js","node_modules/escape-html/index.js","setupIndexedDB.js","main.js"],"names":["setupServiceWorker","navigator","deferredPrompt","window","addEventListener","serviceWorker","register","then","registration","console","log","catch","error","installButton","document","querySelector","e","preventDefault","matchMedia","matches","classList","toggle","prompt","userChoice","choiceResult","outcome","instanceOfAny","object","constructors","some","c","idbProxyableTypes","cursorAdvanceMethods","getIdbProxyableTypes","IDBDatabase","IDBObjectStore","IDBIndex","IDBCursor","IDBTransaction","getCursorAdvanceMethods","prototype","advance","continue","continuePrimaryKey","cursorRequestMap","WeakMap","transactionDoneMap","transactionStoreNamesMap","transformCache","reverseTransformCache","promisifyRequest","request","promise","Promise","resolve","reject","unlisten","removeEventListener","success","wrap","result","value","set","cacheDonePromiseForTransaction","tx","has","done","complete","idbProxyTraps","get","target","prop","receiver","objectStoreNames","undefined","objectStore","addTraps","callback","wrapFunction","func","transaction","includes","args","apply","unwrap","storeNames","call","sort","transformCachableValue","Proxy","IDBRequest","newValue","openDB","name","version","blocked","upgrade","blocking","indexedDB","open","openPromise","event","oldVersion","newVersion","db","deleteDB","deleteDatabase","readMethods","writeMethods","cachedMethods","Map","getMethod","targetFuncName","replace","useIndex","isWrite","method","storeName","store","index","shift","returnVal","oldTraps","advanceMethodProps","methodMap","advanceResults","ittrProxiedCursorToOriginalProxy","cursorIteratorTraps","cachedFunc","iterate","cursor","openCursor","proxiedCursor","delete","isIteratorProp","Symbol","asyncIterator","dbPromise","setupIndexedDB","addNewTodoElement","todoListElement","headers","Headers","baseRestUrl","todosOS","contains","createObjectStore","createIndex","unique","deleteIndex","handleAddTodo","trim","getId","id","todo","userId","title","completed","localKey","saved","fetch","body","JSON","stringify","response","json","updateUI","updateTodoInLocal","writeTodoToLocal","count","add","put","todos","forEach","existing","remove","todoToAdd","insertAdjacentHTML","parentElement","style","display","handleRemoveTodo","todoElement","Number","getAttribute","removeChild","children","length","readTodos","startId","localTasks","readLocalTodosFromIndexedDB","push","replaceTodosWithLatestState","reason","readTodosFromIndexedDB","clear","todosFromLocal","key","todosFromStore","data"],"mappings":"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","file":"main.e01c4087.js","sourceRoot":"..","sourcesContent":["export function setupServiceWorker() {\r\n  // Check that service worker api is available\r\n  if (\"serviceWorker\" in navigator) {\r\n    // Use the window load event to keep the page load performant\r\n    window.addEventListener(\"load\", () => {\r\n      navigator.serviceWorker.register(\"sw.js\").then((registration) => {\r\n        console.log(\"Registration succeeded\");\r\n      })\r\n        .catch(error => {\r\n          console.log(\"Registration failed with error\", error);\r\n        });\r\n    });\r\n\r\n    let deferredPrompt;\r\n    const installButton = document.querySelector(\".installButton\");\r\n    window.addEventListener('beforeinstallprompt', (e) => {\r\n      // Prevent Chrome 67 and earlier from automatically showing the prompt\r\n      e.preventDefault();\r\n      console.log(\"before install event received\");\r\n      // Stash the event so it can be triggered later.\r\n\r\n      if (!window.matchMedia('(display-mode: standalone)').matches) {\r\n        deferredPrompt = e;\r\n        installButton.classList.toggle(\"is-visible\");\r\n      }\r\n    });\r\n\r\n    installButton.addEventListener('click', (e) => {\r\n      // hide our user interface that shows our A2HS button\r\n      installButton.classList.toggle(\"is-visible\");\r\n      // Show the prompt\r\n      deferredPrompt.prompt();\r\n      // Wait for the user to respond to the prompt\r\n      deferredPrompt.userChoice\r\n        .then((choiceResult) => {\r\n          if (choiceResult.outcome === 'accepted') {\r\n            console.log('User accepted the A2HS prompt');\r\n            deferredPrompt = null;\r\n          } else {\r\n            console.log('User dismissed the A2HS prompt');\r\n          }\r\n        });\r\n    });\r\n  }\r\n}\r\n","const instanceOfAny = (object, constructors) => constructors.some(c => object instanceof c);\n\nlet idbProxyableTypes;\r\nlet cursorAdvanceMethods;\r\n// This is a function to prevent it throwing up in node environments.\r\nfunction getIdbProxyableTypes() {\r\n    return idbProxyableTypes ||\r\n        (idbProxyableTypes = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction]);\r\n}\r\n// This is a function to prevent it throwing up in node environments.\r\nfunction getCursorAdvanceMethods() {\r\n    return cursorAdvanceMethods || (cursorAdvanceMethods = [\r\n        IDBCursor.prototype.advance,\r\n        IDBCursor.prototype.continue,\r\n        IDBCursor.prototype.continuePrimaryKey,\r\n    ]);\r\n}\r\nconst cursorRequestMap = new WeakMap();\r\nconst transactionDoneMap = new WeakMap();\r\nconst transactionStoreNamesMap = new WeakMap();\r\nconst transformCache = new WeakMap();\r\nconst reverseTransformCache = new WeakMap();\r\nfunction promisifyRequest(request) {\r\n    const promise = new Promise((resolve, reject) => {\r\n        const unlisten = () => {\r\n            request.removeEventListener('success', success);\r\n            request.removeEventListener('error', error);\r\n        };\r\n        const success = () => {\r\n            resolve(wrap(request.result));\r\n            unlisten();\r\n        };\r\n        const error = () => {\r\n            reject(request.error);\r\n            unlisten();\r\n        };\r\n        request.addEventListener('success', success);\r\n        request.addEventListener('error', error);\r\n    });\r\n    promise.then((value) => {\r\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\r\n        // (see wrapFunction).\r\n        if (value instanceof IDBCursor) {\r\n            cursorRequestMap.set(value, request);\r\n        }\r\n    });\r\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\r\n    // is because we create many promises from a single IDBRequest.\r\n    reverseTransformCache.set(promise, request);\r\n    return promise;\r\n}\r\nfunction cacheDonePromiseForTransaction(tx) {\r\n    // Early bail if we've already created a done promise for this transaction.\r\n    if (transactionDoneMap.has(tx))\r\n        return;\r\n    const done = new Promise((resolve, reject) => {\r\n        const unlisten = () => {\r\n            tx.removeEventListener('complete', complete);\r\n            tx.removeEventListener('error', error);\r\n            tx.removeEventListener('abort', error);\r\n        };\r\n        const complete = () => {\r\n            resolve();\r\n            unlisten();\r\n        };\r\n        const error = () => {\r\n            reject(tx.error);\r\n            unlisten();\r\n        };\r\n        tx.addEventListener('complete', complete);\r\n        tx.addEventListener('error', error);\r\n        tx.addEventListener('abort', error);\r\n    });\r\n    // Cache it for later retrieval.\r\n    transactionDoneMap.set(tx, done);\r\n}\r\nlet idbProxyTraps = {\r\n    get(target, prop, receiver) {\r\n        if (target instanceof IDBTransaction) {\r\n            // Special handling for transaction.done.\r\n            if (prop === 'done')\r\n                return transactionDoneMap.get(target);\r\n            // Polyfill for objectStoreNames because of Edge.\r\n            if (prop === 'objectStoreNames') {\r\n                return target.objectStoreNames || transactionStoreNamesMap.get(target);\r\n            }\r\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\r\n            if (prop === 'store') {\r\n                return receiver.objectStoreNames[1] ?\r\n                    undefined : receiver.objectStore(receiver.objectStoreNames[0]);\r\n            }\r\n        }\r\n        // Else transform whatever we get back.\r\n        return wrap(target[prop]);\r\n    },\r\n    has(target, prop) {\r\n        if (target instanceof IDBTransaction && (prop === 'done' || prop === 'store'))\r\n            return true;\r\n        return prop in target;\r\n    },\r\n};\r\nfunction addTraps(callback) {\r\n    idbProxyTraps = callback(idbProxyTraps);\r\n}\r\nfunction wrapFunction(func) {\r\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\r\n    // only create one new func per func.\r\n    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\r\n    if (func === IDBDatabase.prototype.transaction &&\r\n        !('objectStoreNames' in IDBTransaction.prototype)) {\r\n        return function (storeNames, ...args) {\r\n            const tx = func.call(unwrap(this), storeNames, ...args);\r\n            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\r\n            return wrap(tx);\r\n        };\r\n    }\r\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\r\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\r\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\r\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\r\n    // undefined if the end of the cursor has been reached.\r\n    if (getCursorAdvanceMethods().includes(func)) {\r\n        return function (...args) {\r\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\r\n            // the original object.\r\n            func.apply(unwrap(this), args);\r\n            return wrap(cursorRequestMap.get(this));\r\n        };\r\n    }\r\n    return function (...args) {\r\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\r\n        // the original object.\r\n        return wrap(func.apply(unwrap(this), args));\r\n    };\r\n}\r\nfunction transformCachableValue(value) {\r\n    if (typeof value === 'function')\r\n        return wrapFunction(value);\r\n    // This doesn't return, it just creates a 'done' promise for the transaction,\r\n    // which is later returned for transaction.done (see idbObjectHandler).\r\n    if (value instanceof IDBTransaction)\r\n        cacheDonePromiseForTransaction(value);\r\n    if (instanceOfAny(value, getIdbProxyableTypes()))\r\n        return new Proxy(value, idbProxyTraps);\r\n    // Return the same value back if we're not going to transform it.\r\n    return value;\r\n}\r\nfunction wrap(value) {\r\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\r\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\r\n    if (value instanceof IDBRequest)\r\n        return promisifyRequest(value);\r\n    // If we've already transformed this value before, reuse the transformed value.\r\n    // This is faster, but it also provides object equality.\r\n    if (transformCache.has(value))\r\n        return transformCache.get(value);\r\n    const newValue = transformCachableValue(value);\r\n    // Not all types are transformed.\r\n    // These may be primitive types, so they can't be WeakMap keys.\r\n    if (newValue !== value) {\r\n        transformCache.set(value, newValue);\r\n        reverseTransformCache.set(newValue, value);\r\n    }\r\n    return newValue;\r\n}\r\nconst unwrap = (value) => reverseTransformCache.get(value);\n\nexport { wrap as a, addTraps as b, instanceOfAny as c, reverseTransformCache as d, unwrap as e };\n","import { a as wrap, b as addTraps } from './chunk.js';\nexport { e as unwrap, a as wrap } from './chunk.js';\n\n/**\r\n * Open a database.\r\n *\r\n * @param name Name of the database.\r\n * @param version Schema version.\r\n * @param callbacks Additional callbacks.\r\n */\r\nfunction openDB(name, version, { blocked, upgrade, blocking } = {}) {\r\n    const request = indexedDB.open(name, version);\r\n    const openPromise = wrap(request);\r\n    if (upgrade) {\r\n        request.addEventListener('upgradeneeded', (event) => {\r\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction));\r\n        });\r\n    }\r\n    if (blocked)\r\n        request.addEventListener('blocked', () => blocked());\r\n    if (blocking)\r\n        openPromise.then(db => db.addEventListener('versionchange', blocking));\r\n    return openPromise;\r\n}\r\n/**\r\n * Delete a database.\r\n *\r\n * @param name Name of the database.\r\n */\r\nfunction deleteDB(name, { blocked } = {}) {\r\n    const request = indexedDB.deleteDatabase(name);\r\n    if (blocked)\r\n        request.addEventListener('blocked', () => blocked());\r\n    return wrap(request).then(() => undefined);\r\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\r\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\r\nconst cachedMethods = new Map();\r\nfunction getMethod(target, prop) {\r\n    if (!(target instanceof IDBDatabase &&\r\n        !(prop in target) &&\r\n        typeof prop === 'string'))\r\n        return;\r\n    if (cachedMethods.get(prop))\r\n        return cachedMethods.get(prop);\r\n    const targetFuncName = prop.replace(/FromIndex$/, '');\r\n    const useIndex = prop !== targetFuncName;\r\n    const isWrite = writeMethods.includes(targetFuncName);\r\n    if (\r\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\r\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\r\n        !(isWrite || readMethods.includes(targetFuncName)))\r\n        return;\r\n    const method = async function (storeName, ...args) {\r\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\r\n        let target = tx.store;\r\n        if (useIndex)\r\n            target = target.index(args.shift());\r\n        const returnVal = target[targetFuncName](...args);\r\n        if (isWrite)\r\n            await tx.done;\r\n        return returnVal;\r\n    };\r\n    cachedMethods.set(prop, method);\r\n    return method;\r\n}\r\naddTraps(oldTraps => ({\r\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\r\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\r\n}));\n\nexport { openDB, deleteDB };\n","import { b as addTraps, c as instanceOfAny, d as reverseTransformCache, e as unwrap } from './chunk.js';\n\nconst advanceMethodProps = ['continue', 'continuePrimaryKey', 'advance'];\r\nconst methodMap = {};\r\nconst advanceResults = new WeakMap();\r\nconst ittrProxiedCursorToOriginalProxy = new WeakMap();\r\nconst cursorIteratorTraps = {\r\n    get(target, prop) {\r\n        if (!advanceMethodProps.includes(prop))\r\n            return target[prop];\r\n        let cachedFunc = methodMap[prop];\r\n        if (!cachedFunc) {\r\n            cachedFunc = methodMap[prop] = function (...args) {\r\n                advanceResults.set(this, ittrProxiedCursorToOriginalProxy.get(this)[prop](...args));\r\n            };\r\n        }\r\n        return cachedFunc;\r\n    },\r\n};\r\nasync function* iterate(...args) {\r\n    // tslint:disable-next-line:no-this-assignment\r\n    let cursor = this;\r\n    if (!(cursor instanceof IDBCursor)) {\r\n        cursor = await cursor.openCursor(...args);\r\n    }\r\n    if (!cursor)\r\n        return;\r\n    cursor = cursor;\r\n    const proxiedCursor = new Proxy(cursor, cursorIteratorTraps);\r\n    ittrProxiedCursorToOriginalProxy.set(proxiedCursor, cursor);\r\n    // Map this double-proxy back to the original, so other cursor methods work.\r\n    reverseTransformCache.set(proxiedCursor, unwrap(cursor));\r\n    while (cursor) {\r\n        yield proxiedCursor;\r\n        // If one of the advancing methods was not called, call continue().\r\n        cursor = await (advanceResults.get(proxiedCursor) || cursor.continue());\r\n        advanceResults.delete(proxiedCursor);\r\n    }\r\n}\r\nfunction isIteratorProp(target, prop) {\r\n    return (prop === Symbol.asyncIterator &&\r\n        instanceOfAny(target, [IDBIndex, IDBObjectStore, IDBCursor])) || (prop === 'iterate' &&\r\n        instanceOfAny(target, [IDBIndex, IDBObjectStore]));\r\n}\r\naddTraps(oldTraps => ({\r\n    get(target, prop, receiver) {\r\n        if (isIteratorProp(target, prop))\r\n            return iterate;\r\n        return oldTraps.get(target, prop, receiver);\r\n    },\r\n    has(target, prop) {\r\n        return isIteratorProp(target, prop) || oldTraps.has(target, prop);\r\n    },\r\n}));\n","export * from './build/esm/index.js';\nimport './build/esm/async-iterators.js';\n","/*!\n * escape-html\n * Copyright(c) 2012-2013 TJ Holowaychuk\n * Copyright(c) 2015 Andreas Lubbe\n * Copyright(c) 2015 Tiancheng \"Timothy\" Gu\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module variables.\n * @private\n */\n\nvar matchHtmlRegExp = /[\"'&<>]/;\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = escapeHtml;\n\n/**\n * Escape special characters in the given string of html.\n *\n * @param  {string} string The string to escape for inserting into HTML\n * @return {string}\n * @public\n */\n\nfunction escapeHtml(string) {\n  var str = '' + string;\n  var match = matchHtmlRegExp.exec(str);\n\n  if (!match) {\n    return str;\n  }\n\n  var escape;\n  var html = '';\n  var index = 0;\n  var lastIndex = 0;\n\n  for (index = match.index; index < str.length; index++) {\n    switch (str.charCodeAt(index)) {\n      case 34: // \"\n        escape = '&quot;';\n        break;\n      case 38: // &\n        escape = '&amp;';\n        break;\n      case 39: // '\n        escape = '&#39;';\n        break;\n      case 60: // <\n        escape = '&lt;';\n        break;\n      case 62: // >\n        escape = '&gt;';\n        break;\n      default:\n        continue;\n    }\n\n    if (lastIndex !== index) {\n      html += str.substring(lastIndex, index);\n    }\n\n    lastIndex = index + 1;\n    html += escape;\n  }\n\n  return lastIndex !== index\n    ? html + str.substring(lastIndex, index)\n    : html;\n}\n","import { openDB, deleteDB } from \"idb/with-async-ittr\";\r\nimport escapeHTML from \"escape-html\";\r\n\r\nconst dbPromise = setupIndexedDB();\r\nconst addNewTodoElement = document.querySelector(\".new-todo\");\r\nconst todoListElement = document.querySelector(\".todo-list\");\r\nconst headers = new Headers({ 'Content-Type': 'application/json; charset=UTF-8' });\r\nconst baseRestUrl = \"//jsonplaceholder.typicode.com/todos\";\r\n\r\nhandleAddTodo();\r\nhandleRemoveTodo();\r\nreadTodos();\r\n\r\nexport function setupIndexedDB() {\r\n    //check for support of indexeddb\r\n    if ((\"indexedDB\" in window)) {\r\n        return openDB(\"pwa-test-db\", 4, {\r\n            upgrade(db, oldVersion, newVersion, tx) {\r\n                console.log(oldVersion, newVersion);\r\n                let todosOS;\r\n                if (!db.objectStoreNames.contains(\"todos\")) {\r\n                    todosOS = db.createObjectStore(\"todos\");\r\n                } else {\r\n                    todosOS = tx.objectStore(\"todos\");\r\n                }\r\n                if (oldVersion < 2) {\r\n                    todosOS.createIndex(\"localKey\", \"localKey\", { unique: true });\r\n                }\r\n                if (oldVersion < 3) {\r\n                    todosOS.createIndex(\"idLocal\", [\"id\", \"localKey\"], { unique: true });\r\n                }\r\n                if (oldVersion < 4) {\r\n                    todosOS.deleteIndex(\"idLocal\");\r\n                }\r\n\r\n            },\r\n        });\r\n    } else {\r\n        return null;\r\n    }\r\n}\r\n\r\n\r\nif('serviceWorker' in navigator){\r\n  // Handler for messages coming from the service worker\r\n  navigator.serviceWorker.addEventListener('message', (event) => {\r\n    let json = event.data;\r\n    let id = json.localKey;\r\n    json.saved = true;\r\n    updateUI([json], id);\r\n    updateTodoInLocal(json, id);\r\n  });\r\n}\r\nfunction handleAddTodo() {\r\n    /**\r\n     * Add flow:\r\n     * 1a. Attempt to add to server\r\n     *      a. If successful, update in indexed with the updated info (primary key)\r\n     *      b. if unsuccessful and offline, notify user it was unsuccessful and they are working offline - display todo from indexeddb\r\n     * 1b. Store it in indexeddb\r\n     *\r\n     */\r\n    addNewTodoElement.addEventListener(\"change\", async ({ target }) => {\r\n        const value = target.value.trim();\r\n        addNewTodoElement.value = \"\";\r\n        console.log(\"adding todo?\", value);\r\n\r\n        getId().then(id => {\r\n\r\n            let todo = {\r\n                userId: 1,\r\n                title: value,\r\n                completed: false,\r\n                localKey: id,\r\n                saved: false\r\n            };\r\n\r\n            fetch(baseRestUrl, {\r\n                method: 'POST',\r\n                body: JSON.stringify(todo),\r\n                headers: headers\r\n            })\r\n                .then(response => response.json())\r\n                .then(json => {\r\n                    json.saved = true;\r\n                    updateUI([json], id);\r\n                    updateTodoInLocal(json, id);\r\n                    // })\r\n                    // .catch(reason => {\r\n                    //     if (!navigator.onLine) {\r\n                    //         console.log(\"offline so loading from indexeddb\");\r\n                    //          todo]);\r\n                    //     }\r\n                    //     throw reason;\r\n\r\n                });\r\n            //always write to local just in case\r\n            updateUI([todo]);\r\n            writeTodoToLocal(todo, id);\r\n        });\r\n    });\r\n}\r\n\r\nasync function getId() {\r\n    let db = await dbPromise;\r\n    let tx = db.transaction(\"todos\");\r\n    let localCount = await tx.store.index(\"localKey\").count();\r\n    return 200 + localCount + 1;\r\n}\r\n\r\nasync function writeTodoToLocal(todo, id) {\r\n    let db = await dbPromise;\r\n    let tx = db.transaction(\"todos\", \"readwrite\");\r\n    let store = tx.objectStore(\"todos\");\r\n    store.add(todo, id);\r\n    await tx.done;\r\n    console.log(\"Added a todo to the store\", id);\r\n}\r\n\r\nasync function updateTodoInLocal(todo, id) {\r\n    let db = await dbPromise;\r\n    let tx = db.transaction(\"todos\", \"readwrite\");\r\n    let store = tx.objectStore(\"todos\");\r\n    store.put(todo, id);\r\n    await tx.done;\r\n    console.log(\"Added a todo to the store\", id);\r\n}\r\n\r\nfunction updateUI(todos, id) {\r\n    todos.forEach(todo => {\r\n        if (id) {\r\n            const existing = document.querySelector(`li[data-id=\"${id}\"]`);\r\n            if (existing) {\r\n                existing.remove();\r\n            }\r\n        }\r\n        const todoToAdd =\r\n            `<li data-id=\"${id ? id : todo.localKey ? todo.localKey : todo.id}\" ${todo.completed ? ' class=\"completed\"' : \"\"}>\r\n                <input class=\"toggle\" type=\"checkbox\" ${todo.completed ? \"checked\" : \"\"}>\r\n                <label>${escapeHTML(todo.title)}</label>\r\n                <span ${todo.saved ? ' class=\"saved\"' : todo.localKey ? ' class=\"local\"' : \"\"}></span>\r\n                <button class=\"destroy\"></button>\r\n            </li>`;\r\n        todoListElement.insertAdjacentHTML(\"afterbegin\", todoToAdd);\r\n    });\r\n    todoListElement.parentElement.style.display = \"block\";\r\n}\r\n\r\nfunction handleRemoveTodo() {\r\n    /**\r\n     * Remove Flow:\r\n     * 1a. Attempt to remove from server\r\n     *      a. if successful, ?\r\n     *      b. if unsuccessful and offline, notify user\r\n     * 1b. Remove it in indexeddb\r\n     */\r\n    todoListElement.addEventListener(\"click\", async ({ target }) => {\r\n        if (target.classList.contains(\"destroy\")) {\r\n            const todoElement = target.parentElement;\r\n            let db = await dbPromise;\r\n            let tx = db.transaction(\"todos\", \"readwrite\");\r\n            let store = tx.objectStore(\"todos\");\r\n            let deleted = await store.delete(Number(todoElement.getAttribute(\"data-id\")));\r\n            todoListElement.removeChild(todoElement);\r\n            if (todoListElement.children.length === 0) {\r\n                todoListElement.parentElement.style.display = \"none\";\r\n            }\r\n\r\n            await tx.done;\r\n            console.log(\"deleted a todo from the store\");\r\n        }\r\n    });\r\n}\r\n\r\nasync function readTodos() {\r\n    let startId = await getId();\r\n    /**\r\n     * Load flow:\r\n     * 1. Attempt to load from network\r\n     *      1a. If successful then store into indexeddb and display\r\n     *      1b. if unsuccessful and offline then retrieve from indexeddb and display, note to user that they are working offline\r\n     */\r\n    /**\r\n     * Load flow:\r\n     *\r\n     * 1. Read local from indexeddb (wouldn't do this if you had a real backend api to call/save)\r\n     * 2. Read all non-local from rest call\r\n     *      2a. Fallback to indexeddb for non-local\r\n     */\r\n    try {\r\n        let response = await fetch(baseRestUrl, {\r\n            method: 'GET',\r\n            headers: headers\r\n        });\r\n        let json = await response.json();\r\n        updateUI(json);\r\n        let localTasks = await readLocalTodosFromIndexedDB();\r\n        json.push(...localTasks);\r\n        replaceTodosWithLatestState(json, startId);\r\n    } catch (reason) {\r\n        // if (!navigator.onLine) {\r\n            console.log(\"offline so loading from indexeddb\");\r\n            readTodosFromIndexedDB();\r\n        // }\r\n        throw reason;\r\n    }\r\n\r\n}\r\n\r\nasync function replaceTodosWithLatestState(todos, startId) {\r\n    let db = await dbPromise;\r\n    let tx = db.transaction(\"todos\", \"readwrite\");\r\n    let store = tx.objectStore(\"todos\");\r\n    await store.clear();\r\n    for (const todo of todos) {\r\n        let id = todo.localKey ? todo.localKey : todo.id;\r\n        if (!id) {\r\n            id = ++startId;\r\n        }\r\n        store.add(todo, id);\r\n    }\r\n    return tx.done;\r\n}\r\n\r\nasync function readLocalTodosFromIndexedDB() {\r\n    let todosFromLocal = [];\r\n    let db = await dbPromise;\r\n    const tx = db.transaction(\"todos\");\r\n    for await (const cursor of tx.store.index(\"localKey\")) {\r\n        let todo = cursor.value;\r\n        if (!todo.id) {\r\n            todo.localKey = cursor.key;\r\n        }\r\n        todosFromLocal.push(todo);\r\n    }\r\n    updateUI(todosFromLocal);\r\n    return todosFromLocal;\r\n}\r\n\r\nasync function readTodosFromIndexedDB() {\r\n    let db = await dbPromise;\r\n    const tx = db.transaction(\"todos\");\r\n    let todosFromStore = [];\r\n    for await (const cursor of tx.store) {\r\n        let todo = cursor.value;\r\n        if (!todo.id) {\r\n            todo.localKey = cursor.key;\r\n        }\r\n        todosFromStore.push(todo);\r\n    }\r\n    debugger;\r\n\r\n    await tx.done;\r\n    console.log(\"done\");\r\n    if (todosFromStore.length !== 0) {\r\n        updateUI(todosFromStore);\r\n    }\r\n}\r\n","import { setupServiceWorker } from \"./setupServiceWorker\";\r\nimport { setupIndexedDB } from \"./setupIndexedDB\";\r\n\r\nsetupServiceWorker();\r\nsetupIndexedDB();"]}