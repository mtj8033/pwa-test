{"version":3,"sources":["setupServiceWorker.js","node_modules/idb/build/esm/chunk.js","node_modules/idb/build/esm/index.js","node_modules/idb/build/esm/async-iterators.js","node_modules/idb/with-async-ittr.js","node_modules/uuid/lib/rng-browser.js","node_modules/uuid/lib/bytesToUuid.js","node_modules/uuid/v4.js","node_modules/escape-html/index.js","setupIndexedDB.js","main.js"],"names":["setupServiceWorker","navigator","window","addEventListener","serviceWorker","register","then","registration","console","log","catch","error","instanceOfAny","object","constructors","some","c","idbProxyableTypes","cursorAdvanceMethods","getIdbProxyableTypes","IDBDatabase","IDBObjectStore","IDBIndex","IDBCursor","IDBTransaction","getCursorAdvanceMethods","prototype","advance","continue","continuePrimaryKey","cursorRequestMap","WeakMap","transactionDoneMap","transactionStoreNamesMap","transformCache","reverseTransformCache","promisifyRequest","request","promise","Promise","resolve","reject","unlisten","removeEventListener","success","wrap","result","value","set","cacheDonePromiseForTransaction","tx","has","done","complete","idbProxyTraps","get","target","prop","receiver","objectStoreNames","undefined","objectStore","addTraps","callback","wrapFunction","func","transaction","includes","args","apply","unwrap","storeNames","call","sort","transformCachableValue","Proxy","IDBRequest","newValue","openDB","name","version","blocked","upgrade","blocking","indexedDB","open","openPromise","event","oldVersion","newVersion","db","deleteDB","deleteDatabase","readMethods","writeMethods","cachedMethods","Map","getMethod","targetFuncName","replace","useIndex","isWrite","method","storeName","store","index","shift","returnVal","oldTraps","advanceMethodProps","methodMap","advanceResults","ittrProxiedCursorToOriginalProxy","cursorIteratorTraps","cachedFunc","iterate","cursor","openCursor","proxiedCursor","delete","isIteratorProp","Symbol","asyncIterator","dbPromise","setupIndexedDB","addNewTodoElement","document","querySelector","todoListElement","headers","Headers","baseRestUrl","contains","createObjectStore","handleAddTodo","trim","id","todo","userId","title","completed","localKey","saved","fetch","body","JSON","stringify","response","json","updateUI","updateTodoInLocal","writeTodoToLocal","replaceTodosWithLatestState","todos","clear","forEach","add","uuid","put","existing","remove","todoToAdd","insertAdjacentHTML","parentElement","style","display","handleRemoveTodo","classList","todoElement","Number","getAttribute","removeChild","children","length","readTodos","reason","onLine","readTodosFromIndexedDB","key"],"mappings":"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","file":"main.24ed4175.js","sourceRoot":"..","sourcesContent":["export function setupServiceWorker() {\r\n    // Check that service worker api is available\r\n    if (\"serviceWorker\" in navigator) {\r\n        // Use the window load event to keep the page load performant\r\n        window.addEventListener(\"load\", () => {\r\n            navigator.serviceWorker.register(\"sw.js\").then((registration) => {\r\n                console.log(\"Registration succeeded\");\r\n            })\r\n            .catch(error => {\r\n                console.log(\"Registration failed with error\", error);\r\n            });\r\n        });\r\n    }\r\n}","const instanceOfAny = (object, constructors) => constructors.some(c => object instanceof c);\n\nlet idbProxyableTypes;\r\nlet cursorAdvanceMethods;\r\n// This is a function to prevent it throwing up in node environments.\r\nfunction getIdbProxyableTypes() {\r\n    return idbProxyableTypes ||\r\n        (idbProxyableTypes = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction]);\r\n}\r\n// This is a function to prevent it throwing up in node environments.\r\nfunction getCursorAdvanceMethods() {\r\n    return cursorAdvanceMethods || (cursorAdvanceMethods = [\r\n        IDBCursor.prototype.advance,\r\n        IDBCursor.prototype.continue,\r\n        IDBCursor.prototype.continuePrimaryKey,\r\n    ]);\r\n}\r\nconst cursorRequestMap = new WeakMap();\r\nconst transactionDoneMap = new WeakMap();\r\nconst transactionStoreNamesMap = new WeakMap();\r\nconst transformCache = new WeakMap();\r\nconst reverseTransformCache = new WeakMap();\r\nfunction promisifyRequest(request) {\r\n    const promise = new Promise((resolve, reject) => {\r\n        const unlisten = () => {\r\n            request.removeEventListener('success', success);\r\n            request.removeEventListener('error', error);\r\n        };\r\n        const success = () => {\r\n            resolve(wrap(request.result));\r\n            unlisten();\r\n        };\r\n        const error = () => {\r\n            reject(request.error);\r\n            unlisten();\r\n        };\r\n        request.addEventListener('success', success);\r\n        request.addEventListener('error', error);\r\n    });\r\n    promise.then((value) => {\r\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\r\n        // (see wrapFunction).\r\n        if (value instanceof IDBCursor) {\r\n            cursorRequestMap.set(value, request);\r\n        }\r\n    });\r\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\r\n    // is because we create many promises from a single IDBRequest.\r\n    reverseTransformCache.set(promise, request);\r\n    return promise;\r\n}\r\nfunction cacheDonePromiseForTransaction(tx) {\r\n    // Early bail if we've already created a done promise for this transaction.\r\n    if (transactionDoneMap.has(tx))\r\n        return;\r\n    const done = new Promise((resolve, reject) => {\r\n        const unlisten = () => {\r\n            tx.removeEventListener('complete', complete);\r\n            tx.removeEventListener('error', error);\r\n            tx.removeEventListener('abort', error);\r\n        };\r\n        const complete = () => {\r\n            resolve();\r\n            unlisten();\r\n        };\r\n        const error = () => {\r\n            reject(tx.error);\r\n            unlisten();\r\n        };\r\n        tx.addEventListener('complete', complete);\r\n        tx.addEventListener('error', error);\r\n        tx.addEventListener('abort', error);\r\n    });\r\n    // Cache it for later retrieval.\r\n    transactionDoneMap.set(tx, done);\r\n}\r\nlet idbProxyTraps = {\r\n    get(target, prop, receiver) {\r\n        if (target instanceof IDBTransaction) {\r\n            // Special handling for transaction.done.\r\n            if (prop === 'done')\r\n                return transactionDoneMap.get(target);\r\n            // Polyfill for objectStoreNames because of Edge.\r\n            if (prop === 'objectStoreNames') {\r\n                return target.objectStoreNames || transactionStoreNamesMap.get(target);\r\n            }\r\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\r\n            if (prop === 'store') {\r\n                return receiver.objectStoreNames[1] ?\r\n                    undefined : receiver.objectStore(receiver.objectStoreNames[0]);\r\n            }\r\n        }\r\n        // Else transform whatever we get back.\r\n        return wrap(target[prop]);\r\n    },\r\n    has(target, prop) {\r\n        if (target instanceof IDBTransaction && (prop === 'done' || prop === 'store'))\r\n            return true;\r\n        return prop in target;\r\n    },\r\n};\r\nfunction addTraps(callback) {\r\n    idbProxyTraps = callback(idbProxyTraps);\r\n}\r\nfunction wrapFunction(func) {\r\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\r\n    // only create one new func per func.\r\n    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\r\n    if (func === IDBDatabase.prototype.transaction &&\r\n        !('objectStoreNames' in IDBTransaction.prototype)) {\r\n        return function (storeNames, ...args) {\r\n            const tx = func.call(unwrap(this), storeNames, ...args);\r\n            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\r\n            return wrap(tx);\r\n        };\r\n    }\r\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\r\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\r\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\r\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\r\n    // undefined if the end of the cursor has been reached.\r\n    if (getCursorAdvanceMethods().includes(func)) {\r\n        return function (...args) {\r\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\r\n            // the original object.\r\n            func.apply(unwrap(this), args);\r\n            return wrap(cursorRequestMap.get(this));\r\n        };\r\n    }\r\n    return function (...args) {\r\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\r\n        // the original object.\r\n        return wrap(func.apply(unwrap(this), args));\r\n    };\r\n}\r\nfunction transformCachableValue(value) {\r\n    if (typeof value === 'function')\r\n        return wrapFunction(value);\r\n    // This doesn't return, it just creates a 'done' promise for the transaction,\r\n    // which is later returned for transaction.done (see idbObjectHandler).\r\n    if (value instanceof IDBTransaction)\r\n        cacheDonePromiseForTransaction(value);\r\n    if (instanceOfAny(value, getIdbProxyableTypes()))\r\n        return new Proxy(value, idbProxyTraps);\r\n    // Return the same value back if we're not going to transform it.\r\n    return value;\r\n}\r\nfunction wrap(value) {\r\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\r\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\r\n    if (value instanceof IDBRequest)\r\n        return promisifyRequest(value);\r\n    // If we've already transformed this value before, reuse the transformed value.\r\n    // This is faster, but it also provides object equality.\r\n    if (transformCache.has(value))\r\n        return transformCache.get(value);\r\n    const newValue = transformCachableValue(value);\r\n    // Not all types are transformed.\r\n    // These may be primitive types, so they can't be WeakMap keys.\r\n    if (newValue !== value) {\r\n        transformCache.set(value, newValue);\r\n        reverseTransformCache.set(newValue, value);\r\n    }\r\n    return newValue;\r\n}\r\nconst unwrap = (value) => reverseTransformCache.get(value);\n\nexport { wrap as a, addTraps as b, instanceOfAny as c, reverseTransformCache as d, unwrap as e };\n","import { a as wrap, b as addTraps } from './chunk.js';\nexport { e as unwrap, a as wrap } from './chunk.js';\n\n/**\r\n * Open a database.\r\n *\r\n * @param name Name of the database.\r\n * @param version Schema version.\r\n * @param callbacks Additional callbacks.\r\n */\r\nfunction openDB(name, version, { blocked, upgrade, blocking } = {}) {\r\n    const request = indexedDB.open(name, version);\r\n    const openPromise = wrap(request);\r\n    if (upgrade) {\r\n        request.addEventListener('upgradeneeded', (event) => {\r\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction));\r\n        });\r\n    }\r\n    if (blocked)\r\n        request.addEventListener('blocked', () => blocked());\r\n    if (blocking)\r\n        openPromise.then(db => db.addEventListener('versionchange', blocking));\r\n    return openPromise;\r\n}\r\n/**\r\n * Delete a database.\r\n *\r\n * @param name Name of the database.\r\n */\r\nfunction deleteDB(name, { blocked } = {}) {\r\n    const request = indexedDB.deleteDatabase(name);\r\n    if (blocked)\r\n        request.addEventListener('blocked', () => blocked());\r\n    return wrap(request).then(() => undefined);\r\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\r\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\r\nconst cachedMethods = new Map();\r\nfunction getMethod(target, prop) {\r\n    if (!(target instanceof IDBDatabase &&\r\n        !(prop in target) &&\r\n        typeof prop === 'string'))\r\n        return;\r\n    if (cachedMethods.get(prop))\r\n        return cachedMethods.get(prop);\r\n    const targetFuncName = prop.replace(/FromIndex$/, '');\r\n    const useIndex = prop !== targetFuncName;\r\n    const isWrite = writeMethods.includes(targetFuncName);\r\n    if (\r\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\r\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\r\n        !(isWrite || readMethods.includes(targetFuncName)))\r\n        return;\r\n    const method = async function (storeName, ...args) {\r\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\r\n        let target = tx.store;\r\n        if (useIndex)\r\n            target = target.index(args.shift());\r\n        const returnVal = target[targetFuncName](...args);\r\n        if (isWrite)\r\n            await tx.done;\r\n        return returnVal;\r\n    };\r\n    cachedMethods.set(prop, method);\r\n    return method;\r\n}\r\naddTraps(oldTraps => ({\r\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\r\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\r\n}));\n\nexport { openDB, deleteDB };\n","import { b as addTraps, c as instanceOfAny, d as reverseTransformCache, e as unwrap } from './chunk.js';\n\nconst advanceMethodProps = ['continue', 'continuePrimaryKey', 'advance'];\r\nconst methodMap = {};\r\nconst advanceResults = new WeakMap();\r\nconst ittrProxiedCursorToOriginalProxy = new WeakMap();\r\nconst cursorIteratorTraps = {\r\n    get(target, prop) {\r\n        if (!advanceMethodProps.includes(prop))\r\n            return target[prop];\r\n        let cachedFunc = methodMap[prop];\r\n        if (!cachedFunc) {\r\n            cachedFunc = methodMap[prop] = function (...args) {\r\n                advanceResults.set(this, ittrProxiedCursorToOriginalProxy.get(this)[prop](...args));\r\n            };\r\n        }\r\n        return cachedFunc;\r\n    },\r\n};\r\nasync function* iterate(...args) {\r\n    // tslint:disable-next-line:no-this-assignment\r\n    let cursor = this;\r\n    if (!(cursor instanceof IDBCursor)) {\r\n        cursor = await cursor.openCursor(...args);\r\n    }\r\n    if (!cursor)\r\n        return;\r\n    cursor = cursor;\r\n    const proxiedCursor = new Proxy(cursor, cursorIteratorTraps);\r\n    ittrProxiedCursorToOriginalProxy.set(proxiedCursor, cursor);\r\n    // Map this double-proxy back to the original, so other cursor methods work.\r\n    reverseTransformCache.set(proxiedCursor, unwrap(cursor));\r\n    while (cursor) {\r\n        yield proxiedCursor;\r\n        // If one of the advancing methods was not called, call continue().\r\n        cursor = await (advanceResults.get(proxiedCursor) || cursor.continue());\r\n        advanceResults.delete(proxiedCursor);\r\n    }\r\n}\r\nfunction isIteratorProp(target, prop) {\r\n    return (prop === Symbol.asyncIterator &&\r\n        instanceOfAny(target, [IDBIndex, IDBObjectStore, IDBCursor])) || (prop === 'iterate' &&\r\n        instanceOfAny(target, [IDBIndex, IDBObjectStore]));\r\n}\r\naddTraps(oldTraps => ({\r\n    get(target, prop, receiver) {\r\n        if (isIteratorProp(target, prop))\r\n            return iterate;\r\n        return oldTraps.get(target, prop, receiver);\r\n    },\r\n    has(target, prop) {\r\n        return isIteratorProp(target, prop) || oldTraps.has(target, prop);\r\n    },\r\n}));\n","export * from './build/esm/index.js';\nimport './build/esm/async-iterators.js';\n","// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\n\n// getRandomValues needs to be invoked in a context where \"this\" is a Crypto\n// implementation. Also, find the complete implementation of crypto on IE11.\nvar getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||\n                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));\n\nif (getRandomValues) {\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n\n  module.exports = function whatwgRNG() {\n    getRandomValues(rnds8);\n    return rnds8;\n  };\n} else {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var rnds = new Array(16);\n\n  module.exports = function mathRNG() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return rnds;\n  };\n}\n","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n  return ([bth[buf[i++]], bth[buf[i++]], \n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]],\n\tbth[buf[i++]], bth[buf[i++]],\n\tbth[buf[i++]], bth[buf[i++]]]).join('');\n}\n\nmodule.exports = bytesToUuid;\n","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options === 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n","/*!\n * escape-html\n * Copyright(c) 2012-2013 TJ Holowaychuk\n * Copyright(c) 2015 Andreas Lubbe\n * Copyright(c) 2015 Tiancheng \"Timothy\" Gu\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module variables.\n * @private\n */\n\nvar matchHtmlRegExp = /[\"'&<>]/;\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = escapeHtml;\n\n/**\n * Escape special characters in the given string of html.\n *\n * @param  {string} string The string to escape for inserting into HTML\n * @return {string}\n * @public\n */\n\nfunction escapeHtml(string) {\n  var str = '' + string;\n  var match = matchHtmlRegExp.exec(str);\n\n  if (!match) {\n    return str;\n  }\n\n  var escape;\n  var html = '';\n  var index = 0;\n  var lastIndex = 0;\n\n  for (index = match.index; index < str.length; index++) {\n    switch (str.charCodeAt(index)) {\n      case 34: // \"\n        escape = '&quot;';\n        break;\n      case 38: // &\n        escape = '&amp;';\n        break;\n      case 39: // '\n        escape = '&#39;';\n        break;\n      case 60: // <\n        escape = '&lt;';\n        break;\n      case 62: // >\n        escape = '&gt;';\n        break;\n      default:\n        continue;\n    }\n\n    if (lastIndex !== index) {\n      html += str.substring(lastIndex, index);\n    }\n\n    lastIndex = index + 1;\n    html += escape;\n  }\n\n  return lastIndex !== index\n    ? html + str.substring(lastIndex, index)\n    : html;\n}\n","import { openDB, deleteDB } from \"idb/with-async-ittr.js\";\r\nimport uuid from \"uuid/v4\";\r\nimport escapeHTML from \"escape-html\";\r\n\r\nconst dbPromise = setupIndexedDB();\r\nconst addNewTodoElement = document.querySelector(\".new-todo\");\r\nconst todoListElement = document.querySelector(\".todo-list\");\r\nconst headers = new Headers({ 'Content-Type': 'application/json; charset=UTF-8' });\r\nconst baseRestUrl = \"//jsonplaceholder.typicode.com/todos\";\r\n\r\nhandleAddTodo();\r\nhandleRemoveTodo();\r\nreadTodos();\r\n\r\nexport function setupIndexedDB() {\r\n    //check for support of indexeddb\r\n    if ((\"indexedDB\" in window)) {\r\n        return openDB(\"pwa-test-db\", 1, {\r\n            upgrade(db, oldVersion, newVersion, transaction) {\r\n                console.log(oldVersion);\r\n                console.log(transaction);\r\n                if (!db.objectStoreNames.contains(\"todos\")) {\r\n                    let todosOS = db.createObjectStore(\"todos\");\r\n                    // todosOS.createIndex(\"text\", \"text\", { unique: false });\r\n                }\r\n            },\r\n        });\r\n    } else {\r\n        return null;\r\n    }\r\n}\r\n\r\n\r\nfunction handleAddTodo() {\r\n    /** \r\n     * Add flow:\r\n     * 1a. Attempt to add to server\r\n     *      a. If successful, update in indexed with the updated info (primary key)\r\n     *      b. if unsuccessful and offline, notify user it was unsuccessful and they are working offline - display todo from indexeddb\r\n     * 1b. Store it in indexeddb with a uuid\r\n     * \r\n     */\r\n    addNewTodoElement.addEventListener(\"change\", async ({ target }) => {\r\n        const value = target.value.trim();\r\n        addNewTodoElement.value = \"\";\r\n        console.log(\"adding todo?\", value);\r\n\r\n        const id = uuid();\r\n\r\n        let todo = {\r\n            userId: 1,\r\n            title: value,\r\n            completed: false,\r\n            localKey: id,\r\n            saved: false\r\n        };\r\n\r\n        fetch(baseRestUrl, {\r\n            method: 'POST',\r\n            body: JSON.stringify(todo),\r\n            headers: headers\r\n        })\r\n            .then(response => response.json())\r\n            .then(json => {\r\n                json.saved = true;\r\n                updateUI([json], id);\r\n                updateTodoInLocal(json, id);\r\n                // })\r\n                // .catch(reason => {\r\n                //     if (!navigator.onLine) {\r\n                //         console.log(\"offline so loading from indexeddb\");\r\n                //         updateUI([todo]);\r\n                //     }\r\n                //     throw reason;\r\n\r\n            });\r\n        //always write to local just in case\r\n        updateUI([todo]);\r\n        writeTodoToLocal(todo, id);\r\n    });\r\n}\r\n\r\nasync function replaceTodosWithLatestState(todos) {\r\n    let db = await dbPromise;\r\n    let tx = db.transaction(\"todos\", \"readwrite\");\r\n    let store = tx.objectStore(\"todos\");\r\n    await store.clear();\r\n    todos.forEach(todo => {\r\n        const id = uuid();\r\n        store.add(todo, id);\r\n    });\r\n    return tx.done;\r\n}\r\n\r\nasync function writeTodoToLocal(todo, uuid) {\r\n    let db = await dbPromise;\r\n    let tx = db.transaction(\"todos\", \"readwrite\");\r\n    let store = tx.objectStore(\"todos\");\r\n    store.add(todo, uuid);\r\n    await tx.done;\r\n    console.log(\"Added a todo to the store\", uuid);\r\n}\r\n\r\nasync function updateTodoInLocal(todo, uuid) {\r\n    let db = await dbPromise;\r\n    let tx = db.transaction(\"todos\", \"readwrite\");\r\n    let store = tx.objectStore(\"todos\");\r\n    store.put(todo, uuid);\r\n    await tx.done;\r\n    console.log(\"Added a todo to the store\", uuid);\r\n}\r\n\r\nfunction updateUI(todos, uuid) {\r\n    todos.forEach(todo => {\r\n        if (uuid) {\r\n            const existing = document.querySelector(`li[data-id=\"${uuid}\"]`);\r\n            if (existing) {\r\n                existing.remove();\r\n            }\r\n        }\r\n        const todoToAdd =\r\n            `<li data-id=\"${todo.id ? todo.id : todo.localKey}\" ${todo.completed ? ' class=\"completed\"' : \"\"}>\r\n                <input class=\"toggle\" type=\"checkbox\" ${todo.completed ? \"checked\" : \"\"}>\r\n                <label>${escapeHTML(todo.title)}</label>\r\n                <button ${todo.saved ? ' class=\"saved\"' : todo.localKey ? ' class=\"local\"' : \"\"}></button>\r\n                <button class=\"destroy\"></button>\r\n            </li>`;\r\n        todoListElement.insertAdjacentHTML(\"afterbegin\", todoToAdd);\r\n    });\r\n    todoListElement.parentElement.style.display = \"block\";\r\n}\r\n\r\nfunction handleRemoveTodo() {\r\n    /** \r\n     * Remove Flow:\r\n     * 1a. Attempt to remove from server\r\n     *      a. if successful, ?\r\n     *      b. if unsuccessful and offline, notify user\r\n     * 1b. Remove it in indexeddb\r\n     */\r\n    todoListElement.addEventListener(\"click\", async ({ target }) => {\r\n        if (target.classList.contains(\"destroy\")) {\r\n            const todoElement = target.parentElement;\r\n            let db = await dbPromise;\r\n            let tx = db.transaction(\"todos\", \"readwrite\");\r\n            let store = tx.objectStore(\"todos\");\r\n            await store.delete(Number(todoElement.getAttribute(\"data-id\")));\r\n\r\n            todoListElement.removeChild(todoElement);\r\n            if (todoListElement.children.length === 0) {\r\n                todoListElement.parentElement.style.display = \"none\";\r\n            }\r\n\r\n            await tx.done;\r\n            console.log(\"deleted a todo from the store\");\r\n        }\r\n    });\r\n}\r\n\r\nasync function readTodos() {\r\n    /**\r\n     * Load flow:\r\n     * 1. Attempt to load from network\r\n     *      1a. If successful then store into indexeddb and display\r\n     *      1b. if unsuccessful and offline then retrieve from indexeddb and display, note to user that they are working offline\r\n     */\r\n    /** \r\n     * Load flow:\r\n     * \r\n     * 1. Read unsaved from indexeddb\r\n     * 2. Read all saved local from indexeddb (wouldn't do this if you had a real backend api to call/save)\r\n     * 3. Read all non-local from \r\n     */\r\n    try {\r\n        let response = await fetch(baseRestUrl, {\r\n            method: 'GET',\r\n            headers: headers\r\n        });\r\n        let json = await response.json();\r\n        updateUI(json);\r\n        replaceTodosWithLatestState(json);\r\n    } catch (reason) {\r\n        if (!navigator.onLine) {\r\n            console.log(\"offline so loading from indexeddb\");\r\n            readTodosFromIndexedDB();\r\n        }\r\n        throw reason;\r\n    }\r\n\r\n}\r\n\r\nasync function readTodosFromIndexedDB() {\r\n    let db = await dbPromise;\r\n    const tx = db.transaction(\"todos\");\r\n    let todos = \"\";\r\n    for await (const cursor of tx.store) {\r\n        if (!cursor) return;\r\n        let todo = cursor.value;\r\n        if (!todo.id) {\r\n            todo.localKey = cursor.key;\r\n        }\r\n        updateUI([todo]);\r\n        cursor.continue();\r\n    }\r\n\r\n    await tx.done;\r\n    console.log(\"done\");\r\n    if (todos !== \"\") {\r\n        todoListElement.innerHTML = todos;\r\n        todoListElement.parentElement.style.display = \"block\";\r\n    }\r\n}","import { setupServiceWorker } from \"./setupServiceWorker.js\";\r\nimport { setupIndexedDB } from \"./setupIndexedDB.js\";\r\n\r\nsetupServiceWorker();\r\nsetupIndexedDB();"]}